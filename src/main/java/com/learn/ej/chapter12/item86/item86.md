# Serializable을 구현할지는 신중히 결정하라
- 인스턴스를 직렬화할 수 있게 하려면 implements Serializable만 붙이면 되지만 길게 보면 아주 값비싼 작업이다

### Serializable 구현의 단점
- Serializable을 구현하면 릴리스한 뒤에는 수정하기 어렵다
    - 직렬화된 바이트 스트림 인코딩도 하나의 공개 API가 된다
    - private이나 package-private 필드들 마저 공개 된다
    - 직렬화 가능 클래스르 만들고자 한다며, 감당할 수 있을 만큼 고품질의 직렬화 형태도 함께 설계해야 한다
    - ex) 직렬화된 클래스의 고유 식별번호를 생성하는 로직을 컴파일러가 자동으로 생성하게 한 경우 조그만한 수정에도 UID가 깨질 수 있다
- 버그와 보안 구멍이 생길 위험이 높다
    - 역직렬화는 일반 생성자의 문제가 그대로 적용되는 숨은 생성자이다
    - 생성자에서 구축한 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출된다
- 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다
    - 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화 가능한지, 그 반대도 가능한지
    
### 구현 여부 결정
- 객체를 전송하거나 저장할 때 자바 직렬화를 이용하는 프레임워크용으로 만든 클래스이면 선택의 여지가 없다
- 역사적으로 BigInteger, Instant같은 '값' 클래스와 컬렉션 클래스들은 Serializable을 구현하고
- 스레드 풀처럼 '동작' 하는 객체를 표현하는 클래서는 대부분 구현하지 않는다


### 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안되며, 인터페이스도 대부분 Serializable을 확장하면 안됨
- 해당 클래스나 인터페이스를 확장하거나 구현하는 이에게 큰 부담이 됨
- Serializable을 구현한 클래스만 지원하는 프레임워크를 사용하는 상황이면 다른 방도가 없음
    - 상속용으로 설계된 클래스 중 Serializable을 구현한 예 : Throwable, Component
    - 주의점 1
        - 인스턴스 필드 값 중 불변식을 보장해야 할 게 있으면 하위 클래스에서 finalize 메서드를 재정의 하지 못하게 해야 함
        - 즉, finalize 메서드를 자신이 재정의하면서 final로 선언하면 됨
        - finalizer 공격을 막기 위함
    - 주의점 2
        - 인스턴스 필드 중 기본값으로 초기화되면 위배되는 불변식이 있다면 클래스에 아래와 같은 readObjectNoData 메서드를 추가해야 함
        ```java
        private void readObjectNoData() throws InvalidObjectException {
            throw new InvalidObjectException("스트림 데이터가 필요합니다");
        }      
        ```
        - 기존의 직렬화 가능 클래스에 직렬화 가능 상위 클래스를 추가하는 드문 경우를 위한 메서드
- Serializable을 구현하지 않기로 한 경우
    - 주의점 1
        - 상속용 클래스이고 직렬화를 지원하지 않는데 하위 클래스에서 직렬화를 지원하려는 경우
        - 직렬화 프록시 패턴 (아이템 90) 사용

### 내부 클래스는 직렬화를 구현하지 말아야 한다
- 내부 클래스에 대한 기본 직렬화 형태는 분명하지 않음
- 단, 정적 멤버 클래스는 Serializable을 구현해도 됨
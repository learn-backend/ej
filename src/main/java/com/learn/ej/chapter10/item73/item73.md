# 추상화 수준에 맞는 예외를 던지라
- 메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버리면 내부 구현 방식을 드러내어 윗 레벨 API를 오염시킨다
- 다음 릴리스에서 구현 방식을 바꾸면 다른 예외가 튀어나와 기존 클라이언트 프로그램을 깨지게 할 수도 있다
- 상위 계층에서 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다
- 이를 예외 번역(exception translation) 이라고 한다

### 예외 번역
```java
try {
    ... // 저수준 추상화를 이용한다.
} catch (LowerLevelException e) {
    // 추상화 수준에 맞게 번역한다.
    throw new HigherLevelException(...);
}
```

### 예외 연쇄
- 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄를 사용하는게 좋다
- 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식이다
```java
try {
    ... // 저수준 추상화를 이용한다.
} catch (LowerLevelException cause) {
// 추상화 수준에 맞게 번역한다.
throw new HigherLevelException(cause);
}
```
- 대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있다
- 그렇지 않더라도 Throwable의 initCause 메서드를 이용해 원인을 직접 못박을 수 있다

### 예외 번역을 남용하면 안된다
- 무턱대고 예외를 전파하는 것보다는 예외 번역이 낫지만, 남용하면 안된다
- 가능하면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서 예외가 발생하지 않도록 하는게 최선이다
- 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 미리 검사하는 방법이 있다
- 아래 계층에서 예외를 피할 수 없다면 차선책으로 로깅 기능을 활용하여 기록해두는 방법이 있다
- 클라이언트 코드와 사용자에게 문제를 전파하지 않으면서 로그를 분석해 조치를 취할 수 있다
